#!/bin/sh

version="
jhalfs development

Originally written by Jeremy Huntwork.
Maintained by Manuel Canales Esparcia.

This program is published under the \
Gnu General Public License, Version 2.
"

usage="\
Usage: $0 [OPTION]

Options:
  -h, --help                    print this help, then exit

  -V, --version                 print version number, then exit

  -d  --directory DIR           use DIR directory for building LFS; all files
                                jhalfs produces will be in the directory
                                DIR/jhalfs

  -P, --get-packages            download the packages and patches

  -D, --download-client CLIENT  use CLIENT as the program for retrieving
                                packages (for use in conjunction with -P)

  -W, --working-copy DIR        use the local working copy placed in DIR
                                as the LFS book

  -L, --LFS-version VER         ckeckout VER version of the LFS book

  -T, --testsuites              add support to run the optional testsuites

  --no-toolchain-test           don't run the toolchain testsuites. This
                                disables also the build of TCL, Expect
                                and DejaGNU

  -M, --run-make                run make on the generated Makefile

  --page_size PAGE              set PAGE as the default page size (letter,
                                A4, or others). This setting is required to
                                build Groff. If no speciffied, \"letter\"
                                will be used
"

help="\
Try '$0 --help' for more information."

exit_missing_arg="\
echo \"Option '\$1' requires an argument\" >&2
echo \"\$help\" >&2
exit 1"

no_dl_client="\
echo \"Could not find a way to download the LFS sources.\" >&2
echo \"Attempting to continue.\" >&2"

while test $# -gt 0 ; do
  case $1 in
    --version | -V )
      echo "$version"
      exit 0
      ;;

    --help | -h )
      echo "$usage"
      exit 0
      ;;

    --LFS-version | -L )
      test $# = 1 && eval "$exit_missing_arg"
      shift
      case $1 in
        dev* | SVN | trunk )
          LFSVRS=development
          ;;
        * )
          echo "$1 is an unsupported version at this time."
          exit 1
          ;;
      esac
      shift
      ;;

    --directory | -d )
      test $# = 1 && eval "$exit_missing_arg"
      shift
      BUILDDIR=$1
      shift
      ;;

    --download-client | -D )
      test $# = 1 && eval "$exit_missing_arg"
      shift
      DL=$1
      shift
      ;;

    --working-copy | -W )
      test $# = 1 && eval "$exit_missing_arg"
      shift
      WC=1
      BOOK=$1
      shift
      ;;

    --testsuites | -T )
      TEST=1
      shift
      ;;

    --get-packages | -P )
      HPKG=1
      shift
      ;;

    --run-make | -M )
      RUNMAKE=1
      shift
      ;;

    --page_size )
      test $# = 1 && eval "$exit_missing_arg"
      shift
      PAGE=$1
      shift
      ;;

    --no-toolchain-test )
      TOOLCHAINTEST=0
      shift
      ;;

    * )
      echo "$usage"
      exit 1
      ;;
  esac
done

# Test to make sure we're running the build as root

if [ "$UID" != "0" ] ; then
  echo "You must be logged in as root to successfully build LFS."
  exit 1
fi

# Find the download client to use, if not already specified.

if [ -z $DL ] ; then
  if [ `type -p wget` ] ; then
    DL=wget
  elif [ `type -p curl` ] ; then
    DL=curl
  else
    eval "$no_dl_client"
  fi
fi

SVN="svn://svn.linuxfromscratch.org"
HTTP=http://ftp.lfs-matrix.net/pub/lfs/lfs-packages/conglomeration
if [ -z $BUILDDIR ] ; then BUILDDIR=/mnt/lfs ; fi
JHALFSDIR=$BUILDDIR/jhalfs
LOGDIR=$JHALFSDIR/logs
LOG=000-jhalfs.log
MKFILE=$JHALFSDIR/Makefile
XSL=dump-lfs-scripts.xsl
FNC=functions
if [ -z $TEST ] ; then TEST=0 ; fi
if [ -z $TOOLCHAINTEST ] ; then TOOLCHAINTEST=1 ; fi
if [ -z $PAGE ] ; then PAGE=letter ; fi

HEADER="# This file is automatically generated by jhalfs
# DO NOT EDIT THIS FILE MANUALLY
#
# Generated on `date \"+%F %X %Z\"`"

get_book() {
  # Check for Subversion instead of just letting the script hit 'svn' and fail.
  test `type -p svn` || eval "echo \"This feature requires Subversion.\"
  exit 1"
  cd $JHALFSDIR

  # Test to make sure the LFS version is set
  if [ -z $LFSVRS ] ; then LFSVRS=development ; fi

  # Set the book's sources directory
  if [ -z $BOOK ] ; then BOOK=lfs-$LFSVRS ; fi

  if [ -z $WC ] ; then
    echo -n "Downloading the LFS Book, version $LFSVRS... "

    # Grab the LFS book fresh if it's missing, otherwise, update it from the
    # repo. If we've already extracted the commands, move on to getting the
    # sources.
    if [ -d lfs-$LFSVRS ] ; then
      cd lfs-$LFSVRS
      if svn up | grep -q At && test -d $JHALFSDIR/commands && \
      test -f $JHALFSDIR/packages && test -f $JHALFSDIR/patches ; then
        echo -ne "done\n"
        get_sources
      else
        echo -ne "done\n"
        extract_commands
      fi
    else
      if [ $LFSVRS = development ] ; then
        svn co $SVN/LFS/trunk/BOOK lfs-$LFSVRS >>$LOGDIR/$LOG 2>&1
      else
        svn co $SVN/LFS/branches/$LFSVRS/BOOK lfs-$LFSVRS >>$LOGDIR/$LOG 2>&1
      fi
      echo -ne "done\n"
      extract_commands
    fi
  else
    echo -ne "Using $BOOK as book's sources ...\n"
    extract_commands
  fi
}

extract_commands() {
  # Check for libxslt instead of just letting the script hit 'xsltproc' and fail.
  test `type -p xsltproc` || eval "echo \"This feature requires libxslt.\"
  exit 1"
  cd $JHALFSDIR

  # Start clean
  if [ -d commands ] ; then rm -rf commands ; fi && mkdir commands
  echo -n "Extracting commands... "

  # Dump the commands in shell script form from the LFS book.
  xsltproc --nonet --xinclude --stringparam testsuite $TEST \
    --stringparam toolchaintest $TOOLCHAINTEST -o ./commands/ \
    $XSL $BOOK/index.xml >>$LOGDIR/$LOG 2>&1

  # Make the scripts executables.
  chmod -R +x $JHALFSDIR/commands

  # Grab the patches and package names.
  cd $JHALFSDIR
  for i in patches packages ; do rm -f $i ; done
  grep "\-version" $BOOK/general.ent | sed -e 's@<!ENTITY @@' -e 's@">@"@' \
  -e '/generic/d' >> packages
  echo `grep "glibc" packages | sed 's@glibc@glibc-linuxthreads@'` >> packages
  grep "ENTITY" $BOOK/patches.ent | sed -e 's/.* "//' -e 's/">//' >> patches

  # Done. Moving on...
  echo -ne "done\n"
  get_sources
}

download() {
  cd $BUILDDIR/sources

  # Hackish fix for the bash-doc and glibc-linuxthreads packages that
  # doesn't conform to norms in the URL scheme.
  DIR=`echo $1 | sed -e 's@-doc@@' -e 's@-linuxthreads@@'`

  # Find the md5 sum for this package.
  if [ $2 != MD5SUMS ] ; then MD5=`grep "  $2" MD5SUMS` ; fi

  if [ ! -f $2 ] ; then
    case $DL in
      wget )
        wget $HTTP/$DIR/$2
        ;;
      curl )
        `curl -# $HTTP/$DIR/$2 -o $2`
        ;;
      * )
        echo "$DL not supported at this time."
        ;;
    esac
  elif ! echo "$MD5" | md5sum -c - >/dev/null 2>/dev/null ; then
    case $DL in
      wget )
        wget -c $HTTP/$DIR/$2
        ;;
      curl )
        `curl -# -C - $HTTP/$DIR/$2 -o $2`
        ;;
      * )
        echo "$DL not supported at this time."
        ;;
    esac
  fi
  if [ $2 != MD5SUMS ] && ! echo "$MD5" | md5sum -c - ; then
    exit 1
  fi
}

get_sources() {

  # Test if the packages must be downloaded
  if [ "$HPKG" = "1" ] ; then

    # This variable is necessary to make sure the `cat $JHALFSDIR/packages`
    # separates each iteration by lines.  It is necessary to have the second
    # ' on the next line.
    IFS='
'

    if [ ! -d $BUILDDIR/sources ] ; then mkdir $BUILDDIR/sources ; fi
    cd $BUILDDIR/sources
    if [ -f MD5SUMS ] ; then rm MD5SUMS ; fi

    download "" MD5SUMS

    # Iterate through each package and grab it, along with any patches it needs.
    for i in `cat $JHALFSDIR/packages` ; do
      PKG=`echo $i | sed 's/-version.*//'`

      # Someone used some silly entities right next to the valid package entities.
      if [ "$PKG" = "expect-lib" -o "$PKG" = "linux-dl" ] ; then continue ; fi

      VRS=`echo $i | sed -e 's/.* //' -e 's/"//g'`
      if [ "$PKG" = "tcl" ] ; then
        FILE="$PKG$VRS-src.tar.bz2"
      else
        FILE="$PKG-$VRS.tar.bz2"
      fi
      download $PKG $FILE
      for patch in `grep "$PKG-&$PKG" $JHALFSDIR/patches` ; do
        PATCH=`echo $patch | sed 's@&'$PKG'-version;@'$VRS'@'`
        download $PKG $PATCH
      done
    done
    # Hardcoded Udev configuration file until find a better way
    download udev udev-config-3.rules
  fi
}

build_Makefile() {
  echo -n "Creating Makefile... "
  cd $JHALFSDIR/commands

  # Start with a clean Makefile.tmp file
  >$MKFILE.tmp

  for file in chapter05/* ; do
    # Keep the script file name
    i=`basename $file`

    # If no testsuites will be run, then TCL, Expect and DejaGNU isn't needed
    if [ "$TOOLCHAINTEST" = "0" ]; then
      if echo $i | grep -q "tcl" ; then
        continue
      elif echo $i | grep -q "expect" ; then
        continue
      elif echo $i | grep -q "dejagnu" ; then
        continue
      fi
    fi

    # First append each name of the script files to a list (this will become
    # the names of the targets in the Makefile
    chapter5="$chapter5 $i"

    # Grab the name of the target (minus the -pass1 or -pass2 in the case of gcc
    # and binutils in chapter 5)
    name=`echo $i | sed -e 's@[0-9]\{3\}-@@' -e 's@-pass[0-9]\{1\}@@'`

    # Set the dependency for the first target.
    if [ -z $PREV ] ; then PREV=022-settingenvironment ; fi

    # Drop in the name of the target on a new line, and the previous target
    # as a dependency. Also call the echo_message function.
(
    cat << EOF

$i:  $PREV
	@\$(call echo_message, Building)
EOF
) >> $MKFILE.tmp

    # Find the version of the command files, if it corresponds with the building of
    # a specific package
    vrs=`grep "^$name-version" $JHALFSDIR/packages | sed -e 's/.* //' -e 's/"//g'`

    # If $vrs isn't empty, we've got a package...
    if [ "$vrs" != "" ] ; then
      if [ "$name" = "tcl" ] ; then
        FILE="$name$vrs-src.tar.bz2"
      else
        FILE="$name-$vrs.tar.bz2"
      fi

      # Insert instructions for unpacking the package and to set
      # the PKGDIR variable.
(
    cat << EOF
	@\$(call unpack,$FILE)
	@ROOT=\`head -n1 /tmp/unpacked | sed 's@/.*@@'\` && \\
	chown -R lfs \$(LFS)\$(SRC)/\$\$ROOT && \\
	echo "PKGDIR=\$(LFS)\$(SRC)/\$\$ROOT" > envars && \\
	echo "export PKGDIR" >> envars && \\
EOF
) >> $MKFILE.tmp

    fi

    # Dump the path to the Binutils or TCL sources directory.
    if [ "$i" = "027-binutils-pass1" -o "$i" = "032-tcl" -o "$i" = "036-binutils-pass2" ] ; then
(
    cat << EOF
	echo "\$(LFS)\$(SRC)/\$\$ROOT" > sources-dir
EOF
) >> $MKFILE.tmp

    # For the Adjusting phase we must to cd to the binutils-build directory.
    elif [ "$i" = "031-adjusting" ] ; then
(
    cat << EOF
	@echo "PKGDIR=\$(LFS)\$(SRC)/binutils-build" > envars && \\
	echo "export PKGDIR" >> envars
EOF
) >> $MKFILE.tmp

    # For the Expect build we need to set the TCLPATH envar.
    elif [ "$i" = "033-expect" ] ; then
(
    cat << EOF
	echo "TCLPATH=\`cat sources-dir\`" >> envars && \\
	echo "export TCLPATH" >> envars
EOF
) >> $MKFILE.tmp

    # Everything else, add a true statment so we don't confuse make
    else
(
    cat << EOF
	true
EOF
) >> $MKFILE.tmp
    fi

    # Insert date and disk usage at the top of the log file, the script run
    # and date and disk usage again at the bottom of the log file.
(
    cat << EOF
	@echo -e "\n\`date\`\n\nKB: \`du -sk --exclude=0??-* \$(LFS)\`\n" >logs/$i && \\
	su - lfs -c "source /home/lfs/.bashrc && $JHALFSDIR/commands/$file" >>logs/$i 2>&1 && \\
	echo -e "\n\`date\`\n\nKB: \`du -sk --exclude=0??-* \$(LFS)\`\n" >>logs/$i
EOF
) >> $MKFILE.tmp

    # Remove the build directory(ies) even if the package build fails, except for
    # Binutils and TCL. In that cases the sources directories are removed
    # only if the build fails.
    if [ "$vrs" != "" ] ; then
      if [ "$i" != "027-binutils-pass1" ] && [ "$i" != "032-tcl" ] && [ "$i" != "036-binutils-pass2" ] ; then
(
    cat << EOF
	@ROOT=\`head -n1 /tmp/unpacked | sed 's@/.*@@'\` && \\
	rm -r \$(LFS)\$(SRC)/\$\$ROOT && \\
	if [ -e \$(LFS)\$(SRC)/$name-build ]; then \\
		rm -r \$(LFS)\$(SRC)/$name-build; \\
	fi;
EOF
) >> $MKFILE.tmp
      fi
    fi

    # Remove the Binutils pass 1 sources after a successful Adjusting phase.
    if [ "$i" = "031-adjusting" ] ; then
(
    cat << EOF
	@rm -r \`cat sources-dir\` && \\
	rm -r \$(LFS)\$(SRC)/binutils-build && \\
	rm sources-dir
EOF
) >> $MKFILE.tmp
    fi

    # Remove the TCL sources after a successful Expect build.
    if [ "$i" = "033-expect" ] ; then
(
    cat << EOF
	@rm -r \`cat sources-dir\` && \\
	rm sources-dir
EOF
) >> $MKFILE.tmp
    fi

    # Include a touch of the target name so make can check
    # if it's already been made.
(
    cat << EOF
	@touch \$@
EOF
) >> $MKFILE.tmp

    # The next two "if" must be after the touch to can check if the sources
    # directories should be retained or deleted.
    if [ "$i" = "027-binutils-pass1" -o "$i" = "036-binutils-pass2" ] ; then
(
    cat << EOF
	@if [ ! -e \$@ ] ; then \\
		ROOT=\`head -n1 /tmp/unpacked | sed 's@/.*@@'\` && \\
		rm -r \$(LFS)\$(SRC)/\$\$ROOT && \\
		rm -r \$(LFS)\$(SRC)/binutils-build; \\
	fi;
EOF
) >> $MKFILE.tmp
    fi

    if [ "$i" = "032-tcl" ] ; then
(
    cat << EOF
	@if [ ! -e \$@ ] ; then \\
		ROOT=\`head -n1 /tmp/unpacked | sed 's@/.*@@'\` && \\
		rm -r \$(LFS)\$(SRC)/\$\$ROOT; \\
	fi;
EOF
) >> $MKFILE.tmp
    fi

    # Keep the script file name for Makefile dependencies.
    PREV=$i
  done

  for file in chapter06/* ; do
    # Keep the script file name
    i=`basename $file`

    # We'll run the chroot commands differently than the others, so skip them in the
    # dependencies and target creation.
    if echo $i | grep -q "chroot" ; then
       continue
    fi

    # First append each name of the script files to a list (this will become
    # the names of the targets in the Makefile
    chapter6="$chapter6 $i"

    # Grab the name of the target
    name=`echo $i | sed -e 's@[0-9]\{3\}-@@'`

    # Set the dependency for the first target.
    if [ -z $PREV ] ; then PREV=055-stripping ; fi

    # Drop in the name of the target on a new line, and the previous target
    # as a dependency. Also call the echo_message function.
(
    cat << EOF

$i:  $PREV
	@\$(call echo_message, Building)
EOF
) >> $MKFILE.tmp

    # Find the version of the command files, if it corresponds with the building of
    # a specific package
    vrs=`grep "^$name-version" $JHALFSDIR/packages | sed -e 's/.* //' -e 's/"//g'`

    # If $vrs isn't empty, we've got a package...
    # Insert instructions for unpacking the package and changing directories
    if [ "$vrs" != "" ] ; then
      FILE="$name-$vrs.tar.bz2"
(
    cat  << EOF
	@\$(call unpack,$FILE)
	@ROOT=\`head -n1 /tmp/unpacked | sed 's@/.*@@'\` && \\
	echo "PKGDIR=\$(SRC)/\$\$ROOT" > envars && \\
	echo "export PKGDIR" >> envars
EOF
) >> $MKFILE.tmp
    fi

    # For the Re-Adjusting phase we must to cd to the binutils-build directory.
    if [ "$i" = "067-readjusting" ] ; then
(
    cat << EOF
	@echo "PKGDIR=\$(SRC)/binutils-build" > envars && \\
	echo "export PKGDIR" >> envars
EOF
) >> $MKFILE.tmp
    fi

    # For Groff we need to set PAGE envar.
    if [ "$i" = "082-groff" ] ; then
(
    cat << EOF
	@echo "PAGE=\$(PAGE)" >> envars && \\
	echo "export PAGE" >> envars
EOF
) >> $MKFILE.tmp
    fi

    # In the mount of kernel filesystems we need to set LFS for CHROOT1
    # and not to use chroot.
    if [ "$i" = "057-kernfs" ] ; then
(
    cat << EOF
	@echo -e "\n\`date\`\n\nKB: \`du -sk --exclude=0??-* \$(LFS)\`\n" >logs/$i && \\
	commands/$file >>logs/$i 2>&1 && \\
	echo -e "\n\`date\`\n\nKB: \`du -sk --exclude=0??-* \$(LFS)\`\n" >>logs/$i
EOF
) >> $MKFILE.tmp

    # The rest of Chapter06
    else
(
    cat << EOF
	@echo -e "\n\`date\`\n\nKB: \`du -skx --exclude=0??-* \$(LFS)\`\n" >logs/$i && \\
	\$(CHROOT1) 'cd /jhalfs && source envars && /jhalfs/commands/$file >>/jhalfs/logs/$i 2>&1' && \\
	echo -e "\n\`date\`\n\nKB: \`du -skx --exclude=0??-* \$(LFS)\`\n" >>logs/$i
EOF
) >> $MKFILE.tmp

    fi

    # Remove the build directory(ies) even if the package build fails.
    if [ "$vrs" != "" ] ; then
(
    cat << EOF
	@ROOT=\`head -n1 /tmp/unpacked | sed 's@/.*@@'\` && \\
	rm -r \$(LFS)\$(SRC)/\$\$ROOT && \\
	if [ -e \$(LFS)\$(SRC)/$name-build ]; then \\
		rm -r \$(LFS)\$(SRC)/$name-build; \\
	fi;
EOF
) >> $MKFILE.tmp
    fi

    # Remove the Binutils pass 2 sources after a successful Re-Adjusting phase.
    if [ "$i" = "067-readjusting" ] ; then
(
    cat << EOF
	@rm -r \`cat sources-dir\` && \\
	rm -r \$(LFS)\$(SRC)/binutils-build && \\
	rm sources-dir
EOF
) >> $MKFILE.tmp
    fi

    # Include a touch of the target name so make can check
    # if it's already been made.
(
    cat << EOF
	@touch \$@
EOF
) >> $MKFILE.tmp

    # Keep the script file name for Makefile dependencies.
    PREV=$i
  done

  # Add a header, some variables and include the function file
  # to the top of the real Makefile.
(
    cat << EOF
$HEADER

SRC= /sources
LFS= $BUILDDIR
PAGE= $PAGE

include functions

EOF
) > $MKFILE


  # Add chroot commands
  i=1
  for file in chapter06/*chroot* ; do
    chroot=`cat $file | sed -e '/#!\/bin\/sh/d' -e 's@ \\\@ @g' | tr -d '\n' | sed \
      -e 's/  */ /g' -e 's|\\$|&&|g' -e 's|&&exit||g' -e 's|$| -c|' -e 's|"$$LFS"|$(LFS)|'`
    echo -e "CHROOT$i= $chroot\n" >> $MKFILE
    i=`expr $i + 1`
  done

  # Drop in the main target 'all:' and the chapter targets with each sub-target
  # as a dependency.
(
    cat << EOF
all:  chapter4 chapter5 chapter6
	@echo -e "\n\tYour new LFS system has been successfully built"

chapter4:  020-creatingtoolsdir 021-addinguser 022-settingenvironment

chapter5:  chapter4 $chapter5

chapter6:  chapter5 $chapter6

clean-all:  clean
	rm -rf ./*

clean:  clean-chapter5 clean-chapter4

clean-chapter4:
	-userdel lfs
	rm -rf /home/lfs
	rm -rf \$(LFS)/tools
	rm -f /tools
	rm -f envars
	rm -f 02* logs/02*.log

clean-chapter5:
	rm -rf \$(LFS)/tools/*
	rm -f envars
	rm -f $chapter5
	cd logs && rm -f $chapter5 && cd ..

020-creatingtoolsdir:
	@\$(call echo_message, Building)
	@mkdir -v \$(LFS)/tools && \\
	ln -sv \$(LFS)/tools / && \\
	touch \$@

021-addinguser:  020-creatingtoolsdir
	@\$(call echo_message, Building)
	@groupadd lfs && \\
	useradd -s /bin/bash -g lfs -m -k /dev/null lfs && \\
	chown lfs \$(LFS)/tools && \\
	chown lfs \$(LFS)/sources && \\
	touch \$@

022-settingenvironment:  021-addinguser
	@\$(call echo_message, Building)
	@echo "exec env -i HOME=\\\$\$HOME TERM=\\\$\$TERM PS1='\u:\w\$$ ' /bin/bash" > /home/lfs/.bash_profile && \\
	echo "set +h" > /home/lfs/.bashrc && \\
	echo "umask 022" >> /home/lfs/.bashrc && \\
	echo "LFS=/mnt/lfs" >> /home/lfs/.bashrc && \\
	echo "LC_ALL=POSIX" >> /home/lfs/.bashrc && \\
	echo "PATH=/tools/bin:/bin:/usr/bin" >> /home/lfs/.bashrc && \\
	echo "export LFS LC_ALL PATH" >> /home/lfs/.bashrc && \\
	echo ". $JHALFSDIR/envars" >> /home/lfs/.bashrc && \\
	chown lfs:lfs /home/lfs/.bash* && \\
	touch envars && \\
	touch \$@
EOF
) >> $MKFILE

  # Bring over the items from the Makefile.tmp
  cat $MKFILE.tmp >> $MKFILE
  rm $MKFILE.tmp
  echo -ne "done\n"
}

run_make() {
  # Test if make must be run.
  if [ "$RUNMAKE" = "1" ] ; then
    # Build the system
    if [ -e $MKFILE ] ; then
      echo -ne "Building the LFS system...\n"
      cd $JHALFSDIR && make
      echo -ne "done\n"
    fi
  fi
}

if [ ! -d $JHALFSDIR ] ; then
  mkdir -p $JHALFSDIR
fi

if [ ! -d $LOGDIR ] ; then
  mkdir $LOGDIR
fi

>$LOGDIR/$LOG

if [ "$PWD" != "$JHALFSDIR" ] ; then
  cp $0 $XSL $FNC $JHALFSDIR/
fi

get_book
build_Makefile
run_make
