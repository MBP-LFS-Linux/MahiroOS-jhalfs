#!/bin/sh

version="
jhalfs development

Originally written by Jeremy Huntwork.
Maintained by Manuel Canales Esparcia.

This program is published under the \
Gnu General Public License, Version 2.
"

usage="\
Usage: $0 [OPTION]

Options:
  -h, --help                    print this help, then exit
  -V, --version                 print version number, then exit
  -L, --LFS-version=VER         use VER version of the LFS book
  -d  --directory=DIR           use DIR directory for building LFS; all files
                                jhalfs produces will be in the directory
                                DIR/jhalfs
  -D, --download-client=CLIENT  use CLIENT as the program for retrieving
                                packages
  -T, --no-testsuites           don't run the package's testsuites
  -P, --have-packages           don't download the packages
"

help="\
Try '$0 --help' for more information."

exit_missing_arg="\
echo \"Option '\$1' requires an argument\" >&2
echo \"\$help\" >&2
exit 1"

no_dl_client="\
echo \"Could not find a way to download the LFS sources.\" >&2
echo \"Attempting to continue.\" >&2"

while test $# -gt 0 ; do
  case $1 in
    --version | -V )
      echo "$version"
      exit 0
      ;;

    --help | -h )
      echo "$usage"
      exit 0
      ;;

    --LFS-version | -L )
      test $# = 1 && eval "$exit_missing_arg"
      shift
      case $1 in
        dev* | SVN | trunk )
          LFSVRS=development
          ;;
        * )
          echo "$1 is an unsupported version at this time."
          exit 1
          ;;
      esac
      shift
      ;;

    --directory | -d )
      test $# = 1 && eval "$exit_missing_arg"
      shift
      BUILDDIR=$1
      shift
      ;;

    --download-client | -D )
      test $# = 1 && eval "$exit_missing_arg"
      shift
      DL=$1
      shift
      ;;

    --no-testsuites | -T )
      shift
      TEST=1
      shift
      ;;

    --have-packages | -P )
      shift
      HPKG=1
      shift
      ;;

    * )
      echo "$usage"
      exit 1
      ;;
  esac
done

# Test to make sure we're running the build as root

if [ "$UID" != "0" ] ; then
  echo "You must be logged in as root to successfully build LFS."
  exit 1
fi

# Find the download client to use, if not already specified.

if [ -z $DL ] ; then
  if [ `type -p wget` ] ; then
    DL=wget
  elif [ `type -p curl` ] ; then
    DL=curl
  else
    eval "$no_dl_client"
  fi
fi

SVN="svn://svn.linuxfromscratch.org"
HTTP=http://ftp.lfs-matrix.net/pub/lfs/lfs-packages/conglomeration
if [ -z $BUILDDIR ] ; then BUILDDIR=/mnt/lfs ; fi
JHALFSDIR=$BUILDDIR/jhalfs
LOGDIR=$JHALFSDIR/logs
LOG=000-jhalfs.log
MKFILE=$JHALFSDIR/Makefile
XSL=dump-commands.xsl
if [ -z $TEST ] ; then TEST=0 ; fi

get_book() {
  # Check for Subversion instead of just letting the script hit 'svn' and fail.
  test `type -p svn` || eval "echo \"This feature requires Subversion.\"
  exit 1"
  cd $JHALFSDIR

  # Test to make sure the LFS version is set
  if [ -z $LFSVRS ] ; then LFSVRS=development ; fi
  echo -n "Downloading the LFS Book, version $LFSVRS... "

  # Grab the LFS book fresh if it's missing, otherwise, update it from the
  # repo. If we've already extracted the commands, move on to getting the
  # sources.
  if [ -d lfs-$LFSVRS ] ; then
    cd lfs-$LFSVRS
    if svn up | grep -q At && test -d $JHALFSDIR/commands && \
    test -f $JHALFSDIR/packages && test -f $JHALFSDIR/patches ; then
      echo -ne "done\n"
      get_sources
    else
      echo -ne "done\n"
      extract_commands
    fi
  else
    if [ $LFSVRS = development ] ; then
      svn co $SVN/LFS/trunk/BOOK lfs-$LFSVRS >>$LOGDIR/$LOG 2>&1
    else
      svn co $SVN/LFS/branches/$LFSVRS/BOOK lfs-$LFSVRS >>$LOGDIR/$LOG 2>&1
    fi
    echo -ne "done\n"
    extract_commands
  fi
}

extract_commands() {
  # Check for libxslt instead of just letting the script hit 'xsltproc' and fail.
  test `type -p xsltproc` || eval "echo \"This feature requires libxslt.\"
  exit 1"
  cd $JHALFSDIR

  # Start clean
  if [ -d commands ] ; then rm -rf commands ; fi && mkdir commands
  echo -n "Extracting commands... "

  # Dump the commands in shell script form from the LFS book.
  xsltproc --nonet --xinclude --stringparam testsuite $TEST -o ./commands/ \
  $XSL lfs-$LFSVRS/index.xml >>$LOGDIR/$LOG 2>&1

  # Grab the patches and package names.
  cd $JHALFSDIR
  for i in patches packages ; do rm -f $i ; done
  grep "\-version" lfs-$LFSVRS/general.ent | sed -e 's@<!ENTITY @@' -e 's@">@"@' \
  -e '/generic/d' >> packages
  grep "ENTITY" lfs-$LFSVRS/patches.ent | sed -e 's/.* "//' -e 's/">//' >> patches

  # Done. Moving on...
  echo -ne "done\n"
  get_sources
}

download() {
  cd $BUILDDIR/sources

  # Hackish fix for the bash-doc package that doesn't conform
  # to norms in the URL scheme.
  DIR=`echo $1 | sed 's@-doc@@'`

  # Find the md5 sum for this package.
  if [ $2 != MD5SUMS ] ; then MD5=`grep "  $2" MD5SUMS` ; fi

  if [ ! -f $2 ] ; then
    case $DL in
      wget )
        wget $HTTP/$DIR/$2
        ;;
      curl )
        `curl -# $HTTP/$DIR/$2 -o $2`
        ;;
      * )
        echo "$DL not supported at this time."
        ;;
    esac
  elif ! echo "$MD5" | md5sum -c - >/dev/null 2>/dev/null ; then
    case $DL in
      wget )
        wget -c $HTTP/$DIR/$2
        ;;
      curl )
        `curl -# -C - $HTTP/$DIR/$2 -o $2`
        ;;
      * )
        echo "$DL not supported at this time."
        ;;
    esac
  fi
  if [ $2 != MD5SUMS ] && ! echo "$MD5" | md5sum -c - ; then
    exit 1
  fi
}

get_sources() {

  # Test if the packages must be downloaded
  if [ -z $HPKG ] ; then

    # This variable is necessary to make sure the `cat $JHALFSDIR/packages`
    # separates each iteration by lines.  It is necessary to have the second
    # ' on the next line.
    IFS='
'

    if [ ! -d $BUILDDIR/sources ] ; then mkdir $BUILDDIR/sources ; fi
    cd $BUILDDIR/sources
    if [ -f MD5SUMS ] ; then rm MD5SUMS ; fi

    download "" MD5SUMS

    # Iterate through each package and grab it, along with any patches it needs.
    for i in `cat $JHALFSDIR/packages` ; do
      PKG=`echo $i | sed 's/-version.*//'`

      # Someone used some silly entities right next to the valid package entities.
      if [ "$PKG" = "expect-lib" -o "$PKG" = "linux-dl" ] ; then continue ; fi

      VRS=`echo $i | sed -e 's/.* //' -e 's/"//g'`
      if [ "$PKG" = "tcl" ] ; then
        FILE="$PKG$VRS-src.tar.bz2"
      else
        FILE="$PKG-$VRS.tar.bz2"
      fi
      download $PKG $FILE
      for patch in `grep "$PKG-&$PKG" $JHALFSDIR/patches` ; do
        PATCH=`echo $patch | sed 's@&'$PKG'-version;@'$VRS'@'`
        download $PKG $PATCH
      done
    done
  fi
}

build_Makefile() {
  echo -n "Creating Makefile... "
  cd $JHALFSDIR/commands

  # Start with a clean Makefile.tmp file
  >$MKFILE.tmp

  for file in chapter05/* ; do
  # Keep the script file name
  i=`basename $file`

  # First append each name of the script files to a list (this will become
  # the names of the targets in the Makefile
  chapter5="$chapter5 $i"

  # Grab the name of the target (minus the -pass1 or -pass2 in the case of gcc
  # and binutils in chapter 5)
  name=`echo $i | sed -e 's@[0-9]\{3\}-@@' -e 's@-pass[0-9]\{1\}@@'`

  # Drop in the name of the target on a new line, and the
  # pevious target as a dependency.
  echo -e "\n$i:" >> $MKFILE.tmp

  # Find the version of the command files, if it corresponds with the building of
  # a specific package
  vrs=`grep "^$name-version" $JHALFSDIR/packages | sed -e 's/.* //' -e 's/"//g'`

  # If $vrs isn't empty, we've got a package...
  if [ "$vrs" != "" ] ; then
    if [ "$name" = "tcl" ] ; then
      FILE="$name$vrs-src.tar.bz2"
    else
      FILE="$name-$vrs.tar.bz2"
    fi

    # Insert instructions for unpacking the package and to set
    # the PKGDIR variable.
    echo -e "\t\$(call unpack-lfs,$FILE)" >> $MKFILE.tmp
    echo -e "\t-ROOT=\`head -n1 /tmp/unpacked | sed 's@/.*@@'\` && \\" >> $MKFILE.tmp
    echo -e "\tchown -R lfs \$(LFS)\$(SRC)/\$\$ROOT && \\" >> $MKFILE.tmp
    echo -e "\techo \"PKGDIR=\$(LFS)\$(SRC)/\$\$ROOT\" > envars && \\" >> $MKFILE.tmp
    echo -e "\techo \"export PKGDIR\" >> envars && \\" >> $MKFILE.tmp
  fi

  # Inser date and disk usage at the top of the log file.
  echo -e "\techo -e \"\\\n\`date\`\\\n\\\nKB: \`du -sk --exclude=0??-* \$(LFS)\`\\\n\" >\$(LOGDIR)/$i && \\" >> $MKFILE.tmp

  # Insert the script run
  echo -e "\tsu - lfs -c \". /home/lfs/.bashrc && $JHALFSDIR/commands/$file\" >>\$(LOGDIR)/$i 2>&1 && \\" >> $MKFILE.tmp

  # Inser date and disk usage at the bottom of the log file.
  echo -e "\techo -e \"\\\n\`date\`\\\n\\\nKB: \`du -sk --exclude=0??-* \$(LFS)\`\\\n\" >>\$(LOGDIR)/$i && \\" >> $MKFILE.tmp

  # Include a touch of the target name so make can check
  # if it's already been made.
  echo -e "\ttouch \$@" >> $MKFILE.tmp

  # Remove the build directory(ies) even if the package build fails.
  if [ "$vrs" != "" ] ; then
    echo -e "\tROOT=\`head -n1 /tmp/unpacked | sed 's@/.*@@'\` && \\" >> $MKFILE.tmp
    echo -e "\trm -r \$(LFS)\$(SRC)/\$\$ROOT && \\" >> $MKFILE.tmp
    echo -e "\tif [ -e \$(LFS)\$(SRC)/*-build ]; then \\" >> $MKFILE.tmp
    echo -e "\t\trm -r \$(LFS)\$(SRC)/*-build; \\" >> $MKFILE.tmp
    echo -e "\tfi;" >> $MKFILE.tmp
  fi

  # Check if the package has been sucessfully build.
  echo -e "\tif [ ! -e \$@ ] ; then \\" >> $MKFILE.tmp
  echo -e "\t\techo \"The build of \$@ has failed\" && exit 1; \\" >> $MKFILE.tmp
  echo -e "\tfi;" >> $MKFILE.tmp

  # Keep the script file name in a second variable for Makefile dependencies.
  PREV=$i

  done

  # Stick variables and some defines at the top of the real makefile
  echo "export SRC := /sources" > $MKFILE
  echo "export LFS := $BUILDDIR" >> $MKFILE
  echo -e "export LOGDIR := $LOGDIR\n" >> $MKFILE
  echo "define unpack-lfs" >> $MKFILE
  echo -e "\t@cd \$(LFS)\$(SRC) ; tar -xvjf \$(1) > /tmp/unpacked" >> $MKFILE
  echo -e "endef\n" >> $MKFILE
  echo "define unpack" >> $MKFILE
  echo -e "\t@cd \$(SRC) ; tar -xvf \$(1) > /tmp/unpacked" >> $MKFILE
  echo -e "endef\n" >> $MKFILE

  # Drop in the main target 'all:' and the chapter targets with each sub-target
  # as a dependency.
  echo -e "all:  chapter4 chapter5\n" >> $MKFILE
  echo -e "chapter4:  020-creatingtoolsdir 021-addinguser 022-settingenvironment\n" >> $MKFILE
  echo -e "chapter5:  chapter4 $chapter5\n" >> $MKFILE

  # Clean targets
  echo "clean-all:  clean" >> $MKFILE
  echo -e "\trm -rfv ./*\n" >> $MKFILE

  echo -e "clean:  clean-chapter5 clean-chapter4\n" >> $MKFILE

  echo "clean-chapter4:" >> $MKFILE
  echo -e "\t-userdel lfs" >> $MKFILE
  echo -e "\trm -rfv /home/lfs" >> $MKFILE
  echo -e "\trm -rfv \$(LFS)/tools" >> $MKFILE
  echo -e "\trm -fv /tools" >> $MKFILE
  echo -e "\trm -fv envars" >> $MKFILE
  echo -e "\trm -fv 02* logs/02*.log\n" >> $MKFILE

  echo "clean-chapter5:" >> $MKFILE
  echo -e "\trm -rfv \$(LFS)/tools/*" >> $MKFILE
  echo -e "\trm -fv envars" >> $MKFILE
  echo -e "\trm -fv $chapter5" >> $MKFILE
  echo -e "\tcd logs && rm -fv $chapter5 && cd ..\n" >> $MKFILE

  # The chapter4 sub-targets are hard-coded to can create the lfs user,
  # to make the scripts executables, and to create a clean environment
  # for the lfs user.
  echo "020-creatingtoolsdir:" >> $MKFILE
  echo -e "\tmkdir -v \$(LFS)/tools && \\" >> $MKFILE
  echo -e "\tln -sv \$(LFS)/tools / && \\" >> $MKFILE
  echo -e "\ttouch \$@\n" >> $MKFILE

  echo "021-addinguser:" >> $MKFILE
  echo -e "\tgroupadd lfs && \\" >> $MKFILE
  echo -e "\tuseradd -s /bin/bash -g lfs -m -k /dev/null lfs && \\" >> $MKFILE
  echo -e "\tchown lfs \$(LFS)/tools && \\" >> $MKFILE
  echo -e "\tchown lfs \$(LFS)/sources && \\" >> $MKFILE
  # Make the scripts executables
  echo -e "\tchmod -R +x $JHALFSDIR/commands && \\" >> $MKFILE
  echo -e "\ttouch \$@\n" >> $MKFILE

  echo "022-settingenvironment:" >> $MKFILE
  echo -e "\techo \"exec env -i HOME=\\\$\$HOME TERM=\\\$\$TERM PS1='\u:\w\$$ ' /bin/bash\" > /home/lfs/.bash_profile && \\" >> $MKFILE
  echo -e "\techo \"set +h\" > /home/lfs/.bashrc && \\" >> $MKFILE
  echo -e "\techo \"umask 022\" >> /home/lfs/.bashrc && \\" >> $MKFILE
  echo -e "\techo \"LFS=/mnt/lfs\" >> /home/lfs/.bashrc && \\" >> $MKFILE
  echo -e "\techo \"LC_ALL=POSIX\" >> /home/lfs/.bashrc && \\" >> $MKFILE
  echo -e "\techo \"PATH=/tools/bin:/bin:/usr/bin\" >> /home/lfs/.bashrc && \\" >> $MKFILE
  echo -e "\techo \"export LFS LC_ALL PATH\" >> /home/lfs/.bashrc && \\" >> $MKFILE
  # Source the file where we place changing variables.
  echo -e "\techo \". $JHALFSDIR/envars\" >> /home/lfs/.bashrc && \\" >> $MKFILE
  echo -e "\tchown lfs:lfs /home/lfs/.bash* && \\" >> $MKFILE
  echo -e "\ttouch envars && \\" >> $MKFILE
  echo -e "\ttouch \$@" >> $MKFILE


  # Bring over the items from the Makefile.tmp
  cat $MKFILE.tmp >> $MKFILE
  rm $MKFILE.tmp
  echo -ne "done\n"
}

run_make() {
  # Build the system
  if [ -e $MKFILE ] ; then
    echo -ne "Building the LFS system\n"
    cd $JHALFSDIR && make
    echo -ne "done\n"
  fi
}

if [ ! -d $JHALFSDIR ] ; then
  mkdir -p $JHALFSDIR
fi

if [ ! -d $LOGDIR ] ; then
  mkdir $LOGDIR
fi

>$LOGDIR/$LOG

if [ "$PWD" != "$JHALFSDIR" ] ; then
  cp $0 $XSL $JHALFSDIR/
fi

get_book
build_Makefile
#run_make
